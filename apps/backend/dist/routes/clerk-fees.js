import { Router } from 'express';
import Joi from 'joi';
import { requireRoles } from '../middleware/auth.js';
import { adminSupabase } from '../utils/supabaseAdmin.js';
import { loadAssignedFeeStructure, checkMonthlyFeeComponentsExist } from '../utils/clerkFeeCollection.js';
const router = Router();
// ============================================
// 1. Get Assigned Fee Structure for Student
// ============================================
router.get('/student/:studentId/fee-structure', requireRoles(['clerk', 'principal']), async (req, res) => {
    const { user } = req;
    if (!user || !user.schoolId)
        return res.status(500).json({ error: 'Server misconfigured' });
    const { studentId } = req.params;
    try {
        // Verify student belongs to school
        const { data: student, error: studentError } = await adminSupabase
            .from('students')
            .select('id, school_id, profile:profiles!students_profile_id_fkey(full_name), roll_number, class_groups:class_group_id(name)')
            .eq('id', studentId)
            .eq('school_id', user.schoolId)
            .single();
        if (studentError || !student) {
            return res.status(404).json({ error: 'Student not found or access denied' });
        }
        // Handle Supabase join result (can be object or array)
        const profileData = Array.isArray(student.profile) ? student.profile[0] : student.profile;
        const classGroupData = Array.isArray(student.class_groups) ? student.class_groups[0] : student.class_groups;
        // Load assigned fee structure
        const feeStructure = await loadAssignedFeeStructure(studentId, user.schoolId, adminSupabase);
        // Check if no fee configured
        if (!feeStructure.class_fee && !feeStructure.transport_fee && feeStructure.custom_fees.length === 0) {
            return res.json({
                student: {
                    id: student.id,
                    name: profileData?.full_name || null,
                    roll_number: student.roll_number || null,
                    class: classGroupData?.name || null
                },
                fee_structure: null,
                message: 'No fee configured for this student'
            });
        }
        // Check if monthly components exist (read-only check - generation done by cron)
        // If components don't exist, they will be generated by background job
        // This is safe to call during requests - no writes performed
        await checkMonthlyFeeComponentsExist(studentId, user.schoolId, adminSupabase);
        // Get pagination params (default: 12 months, most recent)
        const page = parseInt(req.query.page) || 1;
        const limit = parseInt(req.query.limit) || 12;
        // Single database call - all aggregation happens in PostgreSQL
        const offset = (page - 1) * limit;
        const { data: ledgerResult, error: rpcError } = await adminSupabase.rpc('get_student_monthly_ledger', {
            p_school_id: user.schoolId,
            p_student_id: studentId,
            p_start_year: null,
            p_end_year: null,
            p_limit: limit,
            p_offset: offset
        });
        if (rpcError) {
            console.error('[clerk-fees/fee-structure] RPC error:', rpcError);
            return res.status(500).json({ error: rpcError.message || 'Failed to get monthly ledger' });
        }
        return res.json({
            student: {
                id: student.id,
                name: profileData?.full_name || null,
                roll_number: student.roll_number || null,
                class: classGroupData?.name || null
            },
            fee_structure: feeStructure,
            monthly_ledger: ledgerResult?.data || [],
            pagination: ledgerResult?.pagination || {
                page,
                limit,
                total: 0,
                total_pages: 0
            }
        });
    }
    catch (err) {
        console.error('[clerk-fees/fee-structure] Error:', err);
        const errorMessage = err instanceof Error ? err.message : 'Failed to load fee structure';
        return res.status(500).json({ error: errorMessage });
    }
});
// ============================================
// 2. Get Monthly Fee Status Ledger (Month-by-Month View)
// ============================================
router.get('/student/:studentId/monthly-ledger', requireRoles(['clerk', 'principal', 'student', 'parent']), async (req, res) => {
    const { user } = req;
    if (!user || !user.schoolId)
        return res.status(500).json({ error: 'Server misconfigured' });
    const { studentId } = req.params;
    const startYear = req.query.start_year ? parseInt(req.query.start_year) : undefined;
    const endYear = req.query.end_year ? parseInt(req.query.end_year) : undefined;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 24; // Default 24 months (2 years)
    try {
        // Verify student belongs to school (or is the student/parent themselves)
        if (user.role === 'student' || user.role === 'parent') {
            // Additional check for students/parents
            const { data: studentCheck } = await adminSupabase
                .from('students')
                .select('id, profile_id')
                .eq('id', studentId)
                .eq('school_id', user.schoolId)
                .single();
            if (!studentCheck) {
                return res.status(404).json({ error: 'Student not found or access denied' });
            }
            if (user.role === 'student' && studentCheck.profile_id !== user.id) {
                return res.status(403).json({ error: 'Access denied' });
            }
            if (user.role === 'parent') {
                // Check if user is a guardian
                const { data: guardian } = await adminSupabase
                    .from('student_guardians')
                    .select('id')
                    .eq('student_id', studentId)
                    .eq('guardian_profile_id', user.id)
                    .single();
                if (!guardian) {
                    return res.status(403).json({ error: 'Access denied' });
                }
            }
        }
        // Check if monthly components exist (read-only check - generation done by cron)
        // If components don't exist, they will be generated by background job
        // This is safe to call during requests - no writes performed
        await checkMonthlyFeeComponentsExist(studentId, user.schoolId, adminSupabase);
        // Single database call - all aggregation happens in PostgreSQL
        const offset = (page - 1) * limit;
        const { data: result, error: rpcError } = await adminSupabase.rpc('get_student_monthly_ledger', {
            p_school_id: user.schoolId,
            p_student_id: studentId,
            p_start_year: startYear || null,
            p_end_year: endYear || null,
            p_limit: limit,
            p_offset: offset
        });
        if (rpcError) {
            console.error('[clerk-fees/monthly-ledger] RPC error:', rpcError);
            return res.status(500).json({ error: rpcError.message || 'Failed to get monthly ledger' });
        }
        if (!result) {
            return res.json({
                student_id: studentId,
                monthly_ledger: [],
                pagination: {
                    page,
                    limit,
                    total: 0,
                    total_pages: 0
                },
                summary: {
                    total_components: 0,
                    total_fee_amount: 0,
                    total_paid_amount: 0,
                    total_pending_amount: 0,
                    pending_count: 0,
                    paid_count: 0
                }
            });
        }
        // Return result directly from database
        return res.json({
            student_id: studentId,
            monthly_ledger: result.data || [],
            pagination: result.pagination || {
                page,
                limit,
                total: 0,
                total_pages: 0
            },
            summary: result.summary || {}
        });
    }
    catch (err) {
        console.error('[clerk-fees/monthly-ledger] Error:', err);
        const errorMessage = err instanceof Error ? err.message : 'Failed to get monthly ledger';
        return res.status(500).json({ error: errorMessage });
    }
});
// ============================================
// 3. Record Fee Payment (Collect Fees)
// ============================================
const collectPaymentSchema = Joi.object({
    monthly_fee_component_ids: Joi.array().items(Joi.string().uuid()).min(1).required(),
    payment_amount: Joi.number().positive().required(),
    payment_date: Joi.date().optional().default(() => new Date()),
    payment_mode: Joi.string().valid('cash', 'upi', 'online', 'card', 'cheque', 'bank_transfer').required(),
    transaction_id: Joi.string().allow('', null).optional(),
    cheque_number: Joi.string().allow('', null).optional(),
    bank_name: Joi.string().allow('', null).optional(),
    notes: Joi.string().allow('', null).optional()
});
router.post('/collect', requireRoles(['clerk', 'principal']), async (req, res) => {
    const { error, value } = collectPaymentSchema.validate(req.body);
    if (error)
        return res.status(400).json({ error: error.message });
    const { user } = req;
    if (!user || !user.schoolId)
        return res.status(500).json({ error: 'Server misconfigured' });
    try {
        const { monthly_fee_component_ids, payment_amount, payment_date, payment_mode, transaction_id, cheque_number, bank_name, notes } = value;
        // Quick validation: Verify components exist and get student_id
        const { data: components, error: componentsError } = await adminSupabase
            .from('monthly_fee_components')
            .select('id, student_id, school_id')
            .in('id', monthly_fee_component_ids)
            .eq('school_id', user.schoolId)
            .limit(1);
        if (componentsError || !components || components.length === 0) {
            return res.status(404).json({ error: 'Fee components not found' });
        }
        const studentId = components[0].student_id;
        // Verify student belongs to school
        const { data: student } = await adminSupabase
            .from('students')
            .select('id')
            .eq('id', studentId)
            .eq('school_id', user.schoolId)
            .single();
        if (!student) {
            return res.status(404).json({ error: 'Student not found' });
        }
        // Prepare metadata for RPC
        const paymentMeta = {
            transaction_id: transaction_id || null,
            cheque_number: cheque_number || null,
            bank_name: bank_name || null,
            notes: notes || null
        };
        // âœ… ONE RPC call - all payment logic happens atomically in PostgreSQL
        // Removed: component loops, manual distribution, multiple inserts, multiple updates
        const { data: result, error: rpcError } = await adminSupabase.rpc('collect_fee_payment_atomic', {
            p_school_id: user.schoolId,
            p_student_id: studentId,
            p_component_ids: monthly_fee_component_ids,
            p_amount: payment_amount,
            p_payment_date: payment_date.toISOString().split('T')[0],
            p_mode: payment_mode,
            p_received_by: user.id,
            p_meta: paymentMeta
        });
        if (rpcError || !result?.success) {
            const errorMsg = rpcError?.message || result?.error || 'Unknown error';
            console.error('[clerk-fees/collect] RPC error:', errorMsg);
            return res.status(400).json({ error: errorMsg });
        }
        // Return minimal response - RPC handles all writes
        return res.status(201).json({
            success: true,
            receipt_number: result.receipt,
            payment: {
                amount_paid: result.paid,
                payment_amount: result.paid,
                payment_date: payment_date.toISOString().split('T')[0],
                payment_mode: payment_mode,
                transaction_id: transaction_id || null,
                cheque_number: cheque_number || null,
                bank_name: bank_name || null,
                notes: notes || null,
                receipt_number: result.receipt
            },
            remaining: result.remaining || 0,
            message: 'Payment recorded successfully'
        });
    }
    catch (err) {
        console.error('[clerk-fees/collect] Error:', err);
        const errorMessage = err instanceof Error ? err.message : 'Failed to record payment';
        return res.status(500).json({ error: errorMessage });
    }
});
// ============================================
// 4. Get Payment Receipt
// ============================================
router.get('/receipt/:paymentId', requireRoles(['clerk', 'principal', 'student', 'parent']), async (req, res) => {
    const { user } = req;
    if (!user || !user.schoolId)
        return res.status(500).json({ error: 'Server misconfigured' });
    const { paymentId } = req.params;
    try {
        // Single query with all joins - fetches everything in one round trip
        const { data: payment, error: paymentError } = await adminSupabase
            .from('monthly_fee_payments')
            .select(`
        id,
        monthly_fee_component_id,
        student_id,
        school_id,
        payment_amount,
        payment_mode,
        payment_date,
        receipt_number,
        received_by,
        transaction_id,
        cheque_number,
        bank_name,
        notes,
        monthly_fee_components:monthly_fee_component_id(
          fee_name,
          fee_type,
          period_year,
          period_month,
          fee_amount,
          fee_categories:fee_category_id(
            id,
            name
          )
        ),
        students:student_id(
          id,
          roll_number,
          profile_id,
          class_group_id,
          profile:profiles!students_profile_id_fkey(
            id,
            full_name,
            email,
            phone
          ),
          class_groups:class_group_id(
            id,
            name
          )
        ),
        received_by_profile:profiles!monthly_fee_payments_received_by_fkey(
          id,
          full_name
        ),
        schools:school_id(
          id,
          name,
          address,
          phone,
          email
        )
      `)
            .eq('id', paymentId)
            .eq('school_id', user.schoolId)
            .single();
        if (paymentError || !payment) {
            return res.status(404).json({ error: 'Payment not found' });
        }
        // Verify access for students/parents (after fetching data)
        if (user.role === 'student' || user.role === 'parent') {
            const student = payment.students;
            if (!student) {
                return res.status(404).json({ error: 'Student not found' });
            }
            // Handle array/object response from Supabase join
            const studentData = Array.isArray(student) ? student[0] : student;
            const studentProfile = Array.isArray(studentData?.profile) ? studentData.profile[0] : studentData?.profile;
            if (user.role === 'student' && studentData?.profile_id !== user.id) {
                return res.status(403).json({ error: 'Access denied' });
            }
            if (user.role === 'parent') {
                const { data: guardian } = await adminSupabase
                    .from('student_guardians')
                    .select('id')
                    .eq('student_id', studentData.id)
                    .eq('guardian_profile_id', user.id)
                    .single();
                if (!guardian) {
                    return res.status(403).json({ error: 'Access denied' });
                }
            }
        }
        // Handle Supabase join response format (can be array or object)
        const component = Array.isArray(payment.monthly_fee_components)
            ? payment.monthly_fee_components[0]
            : payment.monthly_fee_components;
        const student = Array.isArray(payment.students)
            ? payment.students[0]
            : payment.students;
        const studentProfile = Array.isArray(student?.profile)
            ? student.profile[0]
            : student?.profile;
        const classGroup = Array.isArray(student?.class_groups)
            ? student.class_groups[0]
            : student?.class_groups;
        const receivedByProfile = Array.isArray(payment.received_by_profile)
            ? payment.received_by_profile[0]
            : payment.received_by_profile;
        const school = Array.isArray(payment.schools)
            ? payment.schools[0]
            : payment.schools;
        const feeCategory = Array.isArray(component?.fee_categories)
            ? component.fee_categories[0]
            : component?.fee_categories;
        // Format receipt data
        const receipt = {
            receipt_number: payment.receipt_number,
            payment_date: payment.payment_date,
            student: {
                name: studentProfile?.full_name || null,
                roll_number: student?.roll_number || null,
                class: classGroup?.name || null,
                email: studentProfile?.email || null,
                phone: studentProfile?.phone || null
            },
            fee_component: {
                fee_name: component?.fee_name || null,
                fee_type: component?.fee_type || null,
                period: component ? `${component.period_month}/${component.period_year}` : null,
                fee_amount: component?.fee_amount || null,
                paid_amount: payment.payment_amount
            },
            payment_details: {
                amount: payment.payment_amount,
                mode: payment.payment_mode,
                transaction_id: payment.transaction_id || null,
                cheque_number: payment.cheque_number || null,
                bank_name: payment.bank_name || null
            },
            received_by: receivedByProfile?.full_name || 'Clerk',
            school: {
                name: school?.name || null,
                address: school?.address || null,
                phone: school?.phone || null,
                email: school?.email || null
            },
            notes: payment.notes || null
        };
        return res.json({ receipt });
    }
    catch (err) {
        console.error('[clerk-fees/receipt] Error:', err);
        return res.status(500).json({ error: err.message || 'Failed to get receipt' });
    }
});
// ============================================
// 5. Get Payment History for Student
// ============================================
router.get('/student/:studentId/payments', requireRoles(['clerk', 'principal', 'student', 'parent']), async (req, res) => {
    const { user } = req;
    if (!user || !user.schoolId)
        return res.status(500).json({ error: 'Server misconfigured' });
    const { studentId } = req.params;
    try {
        // Verify student access
        if (user.role === 'student' || user.role === 'parent') {
            const { data: student } = await adminSupabase
                .from('students')
                .select('id, profile_id')
                .eq('id', studentId)
                .eq('school_id', user.schoolId)
                .single();
            if (!student) {
                return res.status(404).json({ error: 'Student not found' });
            }
            if (user.role === 'student' && student.profile_id !== user.id) {
                return res.status(403).json({ error: 'Access denied' });
            }
            if (user.role === 'parent') {
                const { data: guardian } = await adminSupabase
                    .from('student_guardians')
                    .select('id')
                    .eq('student_id', studentId)
                    .eq('guardian_profile_id', user.id)
                    .single();
                if (!guardian) {
                    return res.status(403).json({ error: 'Access denied' });
                }
            }
        }
        // Get pagination params (default: 50 records)
        const page = parseInt(req.query.page) || 1;
        const limit = Math.min(parseInt(req.query.limit) || 50, 50); // Max 50
        const offset = (page - 1) * limit;
        // Get payment history (explicit columns only, no select *)
        const { data: payments, error: paymentsError } = await adminSupabase
            .from('monthly_fee_payments')
            .select(`
        id,
        monthly_fee_component_id,
        student_id,
        payment_amount,
        payment_date,
        payment_mode,
        receipt_number,
        transaction_id,
        cheque_number,
        bank_name,
        received_by,
        created_at,
        monthly_fee_components:monthly_fee_component_id(
          fee_name,
          fee_type,
          period_year,
          period_month
        ),
        received_by_profile:profiles!monthly_fee_payments_received_by_fkey(
          full_name
        )
      `)
            .eq('student_id', studentId)
            .eq('school_id', user.schoolId)
            .order('payment_date', { ascending: false })
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
        if (paymentsError) {
            return res.status(500).json({ error: paymentsError.message });
        }
        // Get total count for pagination
        const { count } = await adminSupabase
            .from('monthly_fee_payments')
            .select('id', { count: 'exact', head: true })
            .eq('student_id', studentId)
            .eq('school_id', user.schoolId);
        return res.json({
            student_id: studentId,
            payments: payments || [],
            pagination: {
                page,
                limit,
                total: count || 0,
                total_pages: Math.ceil((count || 0) / limit)
            }
        });
    }
    catch (err) {
        console.error('[clerk-fees/payments] Error:', err);
        return res.status(500).json({ error: err.message || 'Failed to get payment history' });
    }
});
// ============================================
// 6. Get Unpaid Fee Analytics
// ============================================
router.get('/analytics/unpaid', requireRoles(['clerk', 'principal']), async (req, res) => {
    const { user } = req;
    if (!user || !user.schoolId)
        return res.status(500).json({ error: 'Server misconfigured' });
    // IMPORTANT: All queries in this endpoint MUST filter by user.schoolId to ensure
    // principals/clerks only see data from their own school
    try {
        const { class_group_id, time_scope, page = 1, limit = 20 } = req.query;
        // Validate time scope
        const validTimeScopes = ['last_month', 'last_2_months', 'last_3_months', 'last_6_months', 'current_academic_year', 'custom'];
        const timeScope = time_scope || 'last_month';
        if (!validTimeScopes.includes(timeScope)) {
            return res.status(400).json({ error: 'Invalid time scope' });
        }
        // Calculate date range based on time scope
        const today = new Date();
        let startDate;
        let endDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        switch (timeScope) {
            case 'last_month':
                startDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                break;
            case 'last_2_months':
                startDate = new Date(today.getFullYear(), today.getMonth() - 2, 1);
                break;
            case 'last_3_months':
                startDate = new Date(today.getFullYear(), today.getMonth() - 3, 1);
                break;
            case 'last_6_months':
                startDate = new Date(today.getFullYear(), today.getMonth() - 6, 1);
                break;
            case 'current_academic_year':
                // Assume academic year starts in April (month 3)
                const currentMonth = today.getMonth();
                const academicYearStart = currentMonth >= 3
                    ? new Date(today.getFullYear(), 3, 1) // April of current year
                    : new Date(today.getFullYear() - 1, 3, 1); // April of previous year
                startDate = academicYearStart;
                break;
            default:
                startDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        }
        // Convert dates to ISO strings for PostgreSQL
        const startDateStr = startDate ? startDate.toISOString().split('T')[0] : null;
        const endDateStr = endDate ? endDate.toISOString().split('T')[0] : null;
        // Parse pagination parameters
        const pageNum = parseInt(page) || 1;
        const limitNum = parseInt(limit) || 20;
        const offset = (pageNum - 1) * limitNum;
        // Use RPC function which properly filters by class_group_id and date range
        // This ensures ALL summary stats respect the selected filters
        const { data: result, error: rpcError } = await adminSupabase.rpc('get_unpaid_fee_analytics', {
            p_school_id: user.schoolId,
            p_class_group_id: class_group_id || null,
            p_start_date: startDateStr,
            p_end_date: endDateStr,
            p_page_limit: limitNum,
            p_page_offset: offset
        });
        if (rpcError) {
            console.error('[analytics/unpaid] RPC error:', rpcError);
            return res.status(500).json({ error: rpcError.message || 'Failed to get unpaid fee analytics' });
        }
        // Extract data from JSON result - this is the SINGLE SOURCE OF TRUTH
        const students = result?.students || [];
        const summary = result?.summary || {};
        const pagination = result?.pagination || {};
        // Build chart data from summary (all from same RPC result)
        const chartData = {
            paid: summary.paid_count || 0,
            unpaid: summary.unpaid_count || 0,
            partially_paid: summary.partially_paid_count || 0
        };
        return res.json({
            summary: {
                total_students: summary.total_students || 0,
                unpaid_count: summary.unpaid_count || 0,
                partially_paid_count: summary.partially_paid_count || 0,
                paid_count: summary.paid_count || 0,
                total_unpaid_amount: summary.total_unpaid_amount || 0
            },
            chart_data: chartData,
            students: students,
            pagination: pagination
        });
    }
    catch (err) {
        console.error('[analytics/unpaid] Error:', err);
        const errorMessage = err instanceof Error ? err.message : 'Failed to get unpaid fee analytics';
        return res.status(500).json({ error: errorMessage });
    }
});
export default router;
