import { Router } from 'express';
import Joi from 'joi';
import { requireRoles } from '../middleware/auth.js';
import { adminSupabase } from '../utils/supabaseAdmin.js';
import {
  loadAssignedFeeStructure,
  checkMonthlyFeeComponentsExist
} from '../utils/clerkFeeCollection.js';

const router = Router();

// ============================================
// 1. Get Assigned Fee Structure for Student
// ============================================
router.get('/student/:studentId/fee-structure', requireRoles(['clerk', 'principal']), async (req, res) => {
  const { user } = req;
  if (!user || !user.schoolId) return res.status(500).json({ error: 'Server misconfigured' });

  const { studentId } = req.params;

  try {
    // Verify student belongs to school
    const { data: student, error: studentError } = await adminSupabase
      .from('students')
      .select('id, school_id, profile:profiles!students_profile_id_fkey(full_name), roll_number, class_groups:class_group_id(name)')
      .eq('id', studentId)
      .eq('school_id', user.schoolId)
      .single();

    if (studentError || !student) {
      return res.status(404).json({ error: 'Student not found or access denied' });
    }

    // Handle Supabase join result (can be object or array)
    const profileData = Array.isArray(student.profile) ? student.profile[0] : student.profile;
    const classGroupData = Array.isArray(student.class_groups) ? student.class_groups[0] : student.class_groups;

    // Load assigned fee structure
    const feeStructure = await loadAssignedFeeStructure(studentId, user.schoolId, adminSupabase);

    // Check if no fee configured
    if (!feeStructure.class_fee && !feeStructure.transport_fee && feeStructure.custom_fees.length === 0) {
      return res.json({
        student: {
          id: student.id,
          name: profileData?.full_name || null,
          roll_number: student.roll_number || null,
          class: classGroupData?.name || null
        },
        fee_structure: null,
        message: 'No fee configured for this student'
      });
    }

    // Check if monthly components exist (read-only check - generation done by cron)
    // If components don't exist, they will be generated by background job
    // This is safe to call during requests - no writes performed
    await checkMonthlyFeeComponentsExist(studentId, user.schoolId, adminSupabase);

    // Get pagination params (default: 12 months, most recent)
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 12;

    // Single database call - all aggregation happens in PostgreSQL
    const offset = (page - 1) * limit;
    const { data: ledgerResult, error: rpcError } = await adminSupabase.rpc('get_student_monthly_ledger', {
      p_school_id: user.schoolId,
      p_student_id: studentId,
      p_start_year: null,
      p_end_year: null,
      p_limit: limit,
      p_offset: offset
    });

    if (rpcError) {
      console.error('[clerk-fees/fee-structure] RPC error:', rpcError);
      return res.status(500).json({ error: rpcError.message || 'Failed to get monthly ledger' });
    }

    return res.json({
      student: {
        id: student.id,
        name: profileData?.full_name || null,
        roll_number: student.roll_number || null,
        class: classGroupData?.name || null
      },
      fee_structure: feeStructure,
      monthly_ledger: ledgerResult?.data || [],
      pagination: ledgerResult?.pagination || {
        page,
        limit,
        total: 0,
        total_pages: 0
      }
    });
  } catch (err: unknown) {
    console.error('[clerk-fees/fee-structure] Error:', err);
    const errorMessage = err instanceof Error ? err.message : 'Failed to load fee structure';
    return res.status(500).json({ error: errorMessage });
  }
});

// ============================================
// 2. Get Monthly Fee Status Ledger (Month-by-Month View)
// ============================================
router.get('/student/:studentId/monthly-ledger', requireRoles(['clerk', 'principal', 'student', 'parent']), async (req, res) => {
  const { user } = req;
  if (!user || !user.schoolId) return res.status(500).json({ error: 'Server misconfigured' });

  const { studentId } = req.params;
  const startYear = req.query.start_year ? parseInt(req.query.start_year as string) : undefined;
  const endYear = req.query.end_year ? parseInt(req.query.end_year as string) : undefined;
  const page = parseInt(req.query.page as string) || 1;
  const limit = parseInt(req.query.limit as string) || 24; // Default 24 months (2 years)

  try {
    // Verify student belongs to school (or is the student/parent themselves)
    if (user.role === 'student' || user.role === 'parent') {
      // Additional check for students/parents
      const { data: studentCheck } = await adminSupabase
        .from('students')
        .select('id, profile_id')
        .eq('id', studentId)
        .eq('school_id', user.schoolId)
        .single();

      if (!studentCheck) {
        return res.status(404).json({ error: 'Student not found or access denied' });
      }

      if (user.role === 'student' && studentCheck.profile_id !== user.id) {
        return res.status(403).json({ error: 'Access denied' });
      }

      if (user.role === 'parent') {
        // Check if user is a guardian
        const { data: guardian } = await adminSupabase
          .from('student_guardians')
          .select('id')
          .eq('student_id', studentId)
          .eq('guardian_profile_id', user.id)
          .single();

        if (!guardian) {
          return res.status(403).json({ error: 'Access denied' });
        }
      }
    }

    // Check if monthly components exist (read-only check - generation done by cron)
    // If components don't exist, they will be generated by background job
    // This is safe to call during requests - no writes performed
    await checkMonthlyFeeComponentsExist(studentId, user.schoolId, adminSupabase);

    // Single database call - all aggregation happens in PostgreSQL
    const offset = (page - 1) * limit;
    const { data: result, error: rpcError } = await adminSupabase.rpc('get_student_monthly_ledger', {
      p_school_id: user.schoolId,
      p_student_id: studentId,
      p_start_year: startYear || null,
      p_end_year: endYear || null,
      p_limit: limit,
      p_offset: offset
    });

    if (rpcError) {
      console.error('[clerk-fees/monthly-ledger] RPC error:', rpcError);
      return res.status(500).json({ error: rpcError.message || 'Failed to get monthly ledger' });
    }

    if (!result) {
      return res.json({
        student_id: studentId,
        monthly_ledger: [],
        pagination: {
          page,
          limit,
          total: 0,
          total_pages: 0
        },
        summary: {
          total_components: 0,
          total_fee_amount: 0,
          total_paid_amount: 0,
          total_pending_amount: 0,
          pending_count: 0,
          paid_count: 0
        }
      });
    }

    // Return result directly from database
    return res.json({
      student_id: studentId,
      monthly_ledger: result.data || [],
      pagination: result.pagination || {
        page,
        limit,
        total: 0,
        total_pages: 0
      },
      summary: result.summary || {}
    });
  } catch (err: unknown) {
    console.error('[clerk-fees/monthly-ledger] Error:', err);
    const errorMessage = err instanceof Error ? err.message : 'Failed to get monthly ledger';
    return res.status(500).json({ error: errorMessage });
  }
});

// ============================================
// 3. Record Fee Payment (Collect Fees)
// ============================================
const collectPaymentSchema = Joi.object({
  monthly_fee_component_ids: Joi.array().items(Joi.string().uuid()).min(1).required(),
  payment_amount: Joi.number().positive().required(),
  payment_date: Joi.date().optional().default(() => new Date()),
  payment_mode: Joi.string().valid('cash', 'upi', 'online', 'card', 'cheque', 'bank_transfer').required(),
  transaction_id: Joi.string().allow('', null).optional(),
  cheque_number: Joi.string().allow('', null).optional(),
  bank_name: Joi.string().allow('', null).optional(),
  notes: Joi.string().allow('', null).optional()
});

router.post('/collect', requireRoles(['clerk', 'principal']), async (req, res) => {
  const { error, value } = collectPaymentSchema.validate(req.body);
  if (error) return res.status(400).json({ error: error.message });

  const { user } = req;
  if (!user || !user.schoolId) return res.status(500).json({ error: 'Server misconfigured' });

  try {
    const { monthly_fee_component_ids, payment_amount, payment_date, payment_mode, transaction_id, cheque_number, bank_name, notes } = value;

    // Get all fee components (only needed fields)
    const { data: components, error: componentsError } = await adminSupabase
      .from('monthly_fee_components')
      .select('id, student_id, fee_amount, paid_amount, pending_amount, period_year, period_month, fee_name, fee_type, fee_category_id, school_id')
      .in('id', monthly_fee_component_ids)
      .eq('school_id', user.schoolId);

    if (componentsError || !components || components.length === 0) {
      return res.status(404).json({ error: 'Fee components not found' });
    }

    // Verify all components belong to same student
    const studentIds = [...new Set(components.map((c: any) => c.student_id))];
    if (studentIds.length !== 1) {
      return res.status(400).json({ error: 'All fee components must belong to the same student' });
    }

    const studentId = studentIds[0];

    // Validate: Prevent payment for future months (unless principal enables advance payments)
    const today = new Date();
    const currentYear = today.getFullYear();
    const currentMonth = today.getMonth() + 1;

    const futureComponents = components.filter((c: any) => {
      return c.period_year > currentYear || 
             (c.period_year === currentYear && c.period_month > currentMonth);
    });

    if (futureComponents.length > 0) {
      // Check if school allows advance payments (for now, reject by default)
      // TODO: Add school settings table to check allow_advance_payments flag
      const futureMonths = futureComponents.map((c: any) => 
        `${c.period_month}/${c.period_year}`
      ).join(', ');
      
      return res.status(400).json({ 
        error: `Cannot record payment for future months (${futureMonths}). Advance payments require Principal approval. Please contact Principal to enable advance payments.` 
      });
    }

    // Verify student belongs to school
    const { data: student } = await adminSupabase
      .from('students')
      .select('id')
      .eq('id', studentId)
      .eq('school_id', user.schoolId)
      .single();

    if (!student) {
      return res.status(404).json({ error: 'Student not found' });
    }

    // Calculate total pending amount
    const totalPending = components.reduce((sum: number, comp: any) => {
      return sum + parseFloat(comp.pending_amount || 0);
    }, 0);

    // Validate: Payment amount should not exceed pending fee
    if (payment_amount > totalPending) {
      return res.status(400).json({ 
        error: `Payment amount (₹${payment_amount.toFixed(2)}) cannot exceed total pending amount (₹${totalPending.toFixed(2)})` 
      });
    }

    // Validate: Payment amount must be positive
    if (payment_amount <= 0) {
      return res.status(400).json({ 
        error: `Payment amount must be greater than 0` 
      });
    }

    // Generate receipt number
    let receiptNumber: string;
    try {
      const { data: receiptData, error: receiptError } = await adminSupabase.rpc('generate_receipt_number', {
        school_uuid: user.schoolId
      });
      
      if (receiptError || !receiptData) {
        // Fallback: manual receipt number generation
        const { count } = await adminSupabase
          .from('monthly_fee_payments')
          .select('id', { count: 'exact', head: true })
          .eq('school_id', user.schoolId)
          .not('receipt_number', 'is', null);
        
        const receiptCount = (count || 0) + 1;
        receiptNumber = `RCP-${new Date().getFullYear()}-${String(receiptCount).padStart(6, '0')}`;
      } else {
        receiptNumber = receiptData;
      }
    } catch (err) {
      // Fallback receipt number
      receiptNumber = `RCP-${new Date().getFullYear()}-${Date.now().toString().slice(-6)}`;
    }

    // Distribute payment across components (in order of oldest pending first)
    const sortedComponents = [...components].sort((a: any, b: any) => {
      const dateA = new Date(`${a.period_year}-${String(a.period_month).padStart(2, '0')}-01`);
      const dateB = new Date(`${b.period_year}-${String(b.period_month).padStart(2, '0')}-01`);
      return dateA.getTime() - dateB.getTime();
    });

    let remainingPayment = payment_amount;
    const paymentsToInsert: Array<{
      monthly_fee_component_id: string;
      student_id: string;
      school_id: string;
      payment_amount: number;
      payment_date: string;
      payment_mode: string;
      transaction_id: string | null;
      cheque_number: string | null;
      bank_name: string | null;
      received_by: string;
      receipt_number: string;
      notes: string | null;
    }> = [];

    // Build array of payment objects (no database calls yet)
    for (const component of sortedComponents) {
      if (remainingPayment <= 0) break;

      const pendingAmount = parseFloat(component.pending_amount || 0);
      if (pendingAmount <= 0) continue;

      const amountToPay = Math.min(remainingPayment, pendingAmount);

      // Add payment object to array (will insert all at once)
      paymentsToInsert.push({
        monthly_fee_component_id: component.id,
        student_id: studentId,
        school_id: user.schoolId,
        payment_amount: amountToPay,
        payment_date: payment_date.toISOString().split('T')[0],
        payment_mode: payment_mode,
        transaction_id: transaction_id || null,
        cheque_number: cheque_number || null,
        bank_name: bank_name || null,
        received_by: user.id,
        receipt_number: receiptNumber,
        notes: notes || null
      });

      remainingPayment -= amountToPay;
    }

    // Verify that at least one payment will be recorded
    if (paymentsToInsert.length === 0) {
      return res.status(500).json({ 
        error: 'No payment was recorded. Please check that selected components have pending amounts.' 
      });
    }

    // Batch insert all payments in a single query
    const { data: payments, error: paymentError } = await adminSupabase
      .from('monthly_fee_payments')
      .insert(paymentsToInsert)
      .select();

    if (paymentError) {
      console.error('[clerk-fees/collect] Payment batch insert error:', paymentError);
      return res.status(500).json({ error: `Failed to record payment: ${paymentError.message}` });
    }

    // Check if there's any remaining payment (should not happen with new validation, but keep for safety)
    if (remainingPayment > 0.01) { // Allow small rounding differences (1 paisa)
      console.warn(`[clerk-fees/collect] Warning: Remaining payment ${remainingPayment} after distribution. This should not happen with validation.`);
      // This should not happen with the new validation, but if it does, we'll log it
      // The payment has already been recorded for the selected components
    }

    // Get updated components to return status (only fields needed by frontend)
    const { data: updatedComponents } = await adminSupabase
      .from('monthly_fee_components')
      .select('id, paid_amount, pending_amount, status')
      .in('id', monthly_fee_component_ids)
      .eq('school_id', user.schoolId);

    return res.status(201).json({
      success: true,
      receipt_number: receiptNumber,
      payment: {
        id: payments[0]?.id,
        amount_paid: payment_amount,
        payment_amount: payment_amount,
        payment_date: payment_date.toISOString().split('T')[0],
        payment_mode: payment_mode,
        transaction_id: transaction_id || null,
        cheque_number: cheque_number || null,
        bank_name: bank_name || null,
        notes: notes || null,
        receipt_number: receiptNumber
      },
      payments: payments, // Return all payment records created
      components: updatedComponents,
      message: 'Payment recorded successfully'
    });
  } catch (err: unknown) {
    console.error('[clerk-fees/collect] Error:', err);
    const errorMessage = err instanceof Error ? err.message : 'Failed to record payment';
    return res.status(500).json({ error: errorMessage });
  }
});

// ============================================
// 4. Get Payment Receipt
// ============================================
router.get('/receipt/:paymentId', requireRoles(['clerk', 'principal', 'student', 'parent']), async (req, res) => {
  const { user } = req;
  if (!user || !user.schoolId) return res.status(500).json({ error: 'Server misconfigured' });

  const { paymentId } = req.params;

  try {
    // Single query with all joins - fetches everything in one round trip
    const { data: payment, error: paymentError } = await adminSupabase
      .from('monthly_fee_payments')
      .select(`
        id,
        monthly_fee_component_id,
        student_id,
        school_id,
        payment_amount,
        payment_mode,
        payment_date,
        receipt_number,
        received_by,
        transaction_id,
        cheque_number,
        bank_name,
        notes,
        monthly_fee_components:monthly_fee_component_id(
          fee_name,
          fee_type,
          period_year,
          period_month,
          fee_amount,
          fee_categories:fee_category_id(
            id,
            name
          )
        ),
        students:student_id(
          id,
          roll_number,
          profile_id,
          class_group_id,
          profile:profiles!students_profile_id_fkey(
            id,
            full_name,
            email,
            phone
          ),
          class_groups:class_group_id(
            id,
            name
          )
        ),
        received_by_profile:profiles!monthly_fee_payments_received_by_fkey(
          id,
          full_name
        ),
        schools:school_id(
          id,
          name,
          address,
          phone,
          email
        )
      `)
      .eq('id', paymentId)
      .eq('school_id', user.schoolId)
      .single();

    if (paymentError || !payment) {
      return res.status(404).json({ error: 'Payment not found' });
    }

    // Verify access for students/parents (after fetching data)
    if (user.role === 'student' || user.role === 'parent') {
      const student = payment.students;
      if (!student) {
        return res.status(404).json({ error: 'Student not found' });
      }

      // Handle array/object response from Supabase join
      const studentData = Array.isArray(student) ? student[0] : student;
      const studentProfile = Array.isArray(studentData?.profile) ? studentData.profile[0] : studentData?.profile;

      if (user.role === 'student' && studentData?.profile_id !== user.id) {
        return res.status(403).json({ error: 'Access denied' });
      }
      if (user.role === 'parent') {
        const { data: guardian } = await adminSupabase
          .from('student_guardians')
          .select('id')
          .eq('student_id', studentData.id)
          .eq('guardian_profile_id', user.id)
          .single();

        if (!guardian) {
          return res.status(403).json({ error: 'Access denied' });
        }
      }
    }

    // Handle Supabase join response format (can be array or object)
    const component = Array.isArray(payment.monthly_fee_components) 
      ? payment.monthly_fee_components[0] 
      : payment.monthly_fee_components;
    
    const student = Array.isArray(payment.students) 
      ? payment.students[0] 
      : payment.students;
    
    const studentProfile = Array.isArray(student?.profile) 
      ? student.profile[0] 
      : student?.profile;
    
    const classGroup = Array.isArray(student?.class_groups) 
      ? student.class_groups[0] 
      : student?.class_groups;
    
    const receivedByProfile = Array.isArray(payment.received_by_profile) 
      ? payment.received_by_profile[0] 
      : payment.received_by_profile;
    
    const school = Array.isArray(payment.schools) 
      ? payment.schools[0] 
      : payment.schools;
    
    const feeCategory = Array.isArray(component?.fee_categories) 
      ? component.fee_categories[0] 
      : component?.fee_categories;

    // Format receipt data
    const receipt = {
      receipt_number: payment.receipt_number,
      payment_date: payment.payment_date,
      student: {
        name: studentProfile?.full_name || null,
        roll_number: student?.roll_number || null,
        class: classGroup?.name || null,
        email: studentProfile?.email || null,
        phone: studentProfile?.phone || null
      },
      fee_component: {
        fee_name: component?.fee_name || null,
        fee_type: component?.fee_type || null,
        period: component ? `${component.period_month}/${component.period_year}` : null,
        fee_amount: component?.fee_amount || null,
        paid_amount: payment.payment_amount
      },
      payment_details: {
        amount: payment.payment_amount,
        mode: payment.payment_mode,
        transaction_id: payment.transaction_id || null,
        cheque_number: payment.cheque_number || null,
        bank_name: payment.bank_name || null
      },
      received_by: receivedByProfile?.full_name || 'Clerk',
      school: {
        name: school?.name || null,
        address: school?.address || null,
        phone: school?.phone || null,
        email: school?.email || null
      },
      notes: payment.notes || null
    };

    return res.json({ receipt });
  } catch (err: any) {
    console.error('[clerk-fees/receipt] Error:', err);
    return res.status(500).json({ error: err.message || 'Failed to get receipt' });
  }
});

// ============================================
// 5. Get Payment History for Student
// ============================================
router.get('/student/:studentId/payments', requireRoles(['clerk', 'principal', 'student', 'parent']), async (req, res) => {
  const { user } = req;
  if (!user || !user.schoolId) return res.status(500).json({ error: 'Server misconfigured' });

  const { studentId } = req.params;

  try {
    // Verify student access
    if (user.role === 'student' || user.role === 'parent') {
      const { data: student } = await adminSupabase
        .from('students')
        .select('id, profile_id')
        .eq('id', studentId)
        .eq('school_id', user.schoolId)
        .single();

      if (!student) {
        return res.status(404).json({ error: 'Student not found' });
      }

      if (user.role === 'student' && student.profile_id !== user.id) {
        return res.status(403).json({ error: 'Access denied' });
      }

      if (user.role === 'parent') {
        const { data: guardian } = await adminSupabase
          .from('student_guardians')
          .select('id')
          .eq('student_id', studentId)
          .eq('guardian_profile_id', user.id)
          .single();

        if (!guardian) {
          return res.status(403).json({ error: 'Access denied' });
        }
      }
    }

    // Get pagination params (default: 50 records)
    const page = parseInt(req.query.page as string) || 1;
    const limit = Math.min(parseInt(req.query.limit as string) || 50, 50); // Max 50
    const offset = (page - 1) * limit;

    // Get payment history (explicit columns only, no select *)
    const { data: payments, error: paymentsError } = await adminSupabase
      .from('monthly_fee_payments')
      .select(`
        id,
        monthly_fee_component_id,
        student_id,
        payment_amount,
        payment_date,
        payment_mode,
        receipt_number,
        transaction_id,
        cheque_number,
        bank_name,
        received_by,
        created_at,
        monthly_fee_components:monthly_fee_component_id(
          fee_name,
          fee_type,
          period_year,
          period_month
        ),
        received_by_profile:profiles!monthly_fee_payments_received_by_fkey(
          full_name
        )
      `)
      .eq('student_id', studentId)
      .eq('school_id', user.schoolId)
      .order('payment_date', { ascending: false })
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (paymentsError) {
      return res.status(500).json({ error: paymentsError.message });
    }

    // Get total count for pagination
    const { count } = await adminSupabase
      .from('monthly_fee_payments')
      .select('id', { count: 'exact', head: true })
      .eq('student_id', studentId)
      .eq('school_id', user.schoolId);

    return res.json({
      student_id: studentId,
      payments: payments || [],
      pagination: {
        page,
        limit,
        total: count || 0,
        total_pages: Math.ceil((count || 0) / limit)
      }
    });
  } catch (err: any) {
    console.error('[clerk-fees/payments] Error:', err);
    return res.status(500).json({ error: err.message || 'Failed to get payment history' });
  }
});

// ============================================
// 6. Get Unpaid Fee Analytics
// ============================================
router.get('/analytics/unpaid', requireRoles(['clerk', 'principal']), async (req, res) => {
  const { user } = req;
  if (!user || !user.schoolId) return res.status(500).json({ error: 'Server misconfigured' });

  // IMPORTANT: All queries in this endpoint MUST filter by user.schoolId to ensure
  // principals/clerks only see data from their own school

  try {
    const { class_group_id, time_scope, page = 1, limit = 20 } = req.query;
    
    // Validate time scope
    const validTimeScopes = ['last_month', 'last_2_months', 'last_3_months', 'last_6_months', 'current_academic_year', 'custom'];
    const timeScope = time_scope as string || 'last_month';
    
    if (!validTimeScopes.includes(timeScope)) {
      return res.status(400).json({ error: 'Invalid time scope' });
    }

    // Calculate date range based on time scope
    const today = new Date();
    let startDate: Date | null;
    let endDate: Date | null = new Date(today.getFullYear(), today.getMonth(), today.getDate());

    switch (timeScope) {
      case 'last_month':
        startDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        break;
      case 'last_2_months':
        startDate = new Date(today.getFullYear(), today.getMonth() - 2, 1);
        break;
      case 'last_3_months':
        startDate = new Date(today.getFullYear(), today.getMonth() - 3, 1);
        break;
      case 'last_6_months':
        startDate = new Date(today.getFullYear(), today.getMonth() - 6, 1);
        break;
      case 'current_academic_year':
        // Assume academic year starts in April (month 3)
        const currentMonth = today.getMonth();
        const academicYearStart = currentMonth >= 3 
          ? new Date(today.getFullYear(), 3, 1)  // April of current year
          : new Date(today.getFullYear() - 1, 3, 1); // April of previous year
        startDate = academicYearStart;
        break;
      default:
        startDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
    }

    // Convert dates to ISO strings for PostgreSQL
    const startDateStr = startDate ? startDate.toISOString().split('T')[0] : null;
    const endDateStr = endDate ? endDate.toISOString().split('T')[0] : null;

    // Parse pagination parameters
    const pageNum = parseInt(page as string) || 1;
    const limitNum = parseInt(limit as string) || 20;
    const offset = (pageNum - 1) * limitNum;

    // Call PostgreSQL function to do all aggregation in the database
    const { data: result, error: rpcError } = await adminSupabase.rpc('get_unpaid_fee_analytics', {
      p_school_id: user.schoolId,
      p_class_group_id: class_group_id || null,
      p_start_date: startDateStr,
      p_end_date: endDateStr,
      p_page_limit: limitNum,
      p_page_offset: offset
    });

    if (rpcError) {
      console.error('[analytics/unpaid] RPC error:', rpcError);
      return res.status(500).json({ error: rpcError.message || 'Failed to get unpaid fee analytics' });
    }

    if (!result) {
      return res.json({
        summary: {
          total_students: 0,
          unpaid_count: 0,
          partially_paid_count: 0,
          paid_count: 0,
          total_unpaid_amount: 0
        },
        chart_data: { paid: 0, unpaid: 0, partially_paid: 0 },
        students: [],
        pagination: { page: 1, limit: 20, total: 0, total_pages: 0 }
      });
    }

    // Extract data from JSON result
    const students = result.students || [];
    const summary = result.summary || {};
    const pagination = result.pagination || {};

    // Build chart data from summary
    const chartData = {
      paid: summary.paid_count || 0,
      unpaid: summary.unpaid_count || 0,
      partially_paid: summary.partially_paid_count || 0
    };

    return res.json({
      summary: {
        total_students: summary.total_students || 0,
        unpaid_count: summary.unpaid_count || 0,
        partially_paid_count: summary.partially_paid_count || 0,
        paid_count: summary.paid_count || 0,
        total_unpaid_amount: summary.total_unpaid_amount || 0
      },
      chart_data: chartData,
      students: students,
      pagination: pagination
    });
  } catch (err: unknown) {
    console.error('[analytics/unpaid] Error:', err);
    const errorMessage = err instanceof Error ? err.message : 'Failed to get unpaid fee analytics';
    return res.status(500).json({ error: errorMessage });
  }
});

export default router;

